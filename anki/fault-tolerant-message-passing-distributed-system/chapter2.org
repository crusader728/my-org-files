* Item                                                    :URB:
:PROPERTIES:
:ANKI_DECK: fault-tolerant-message-passing-distributed-systems
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673072273284
:END:
** Front
macro-operation $boardcast(m)$
** Back
*for each* $j \in \{1 \dots n\}$, *do* send $m$ to $p_j$ *end for*.

* Item                                                    :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673072859246
:END:
** Front
best effort semantics for $boardcast(m)$ in $CAMP_{n,t}[\emptyset]$
** Back
- if the sender $p_i$ is correct, a copy of $m$ is sent to every process
- since the channels are reliable, every process (that has not crashed) receives a copy of $m$


* Item                                                    :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673073156027
:END:

** Front
why $broadcast(m)$ is unreliable
** Back
- copies can be received at independent time instants due to asynchronous channels
- if sender crashes while executing $broadcast(m)$, an arbitrary subset of processes receives $m$.


* Item                                                    :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673073286326
:END:

** Front
$URB\_broadcast(m)$
** Back
allows a process $p_i$ to send a message $m$ to all the processes (including itself)



* Item                                                    :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673073367477
:END:

** Front
$URB\_deliver()$
** Back
allows a process to deliver a message that has been broadcast.



* Item                                                    :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673074097324
:END:

** Front
difference between $URB\_broadcast$, $URB\_deliver$, $send$ and $receive$
** Back
[[file:./data/urb-broadcast-architectural-view.png]]



* Item                                                    :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673074482827
:END:

** Front
assumption of $URB\_broadcast$
** Back
- every message is unique
  - identity of a message $\langle m.sender,m.seq\_nb \rangle$
    - $m.sender$ is the identity of the sender process
    - $m.seq\_nb$ is a sequence number locally generated by $p_{m.sender}$

      
* Item                                                    :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673074679598
:END:
** Front
URB-validity
** Back
if a process urb-delivers a message /m/, then /m/ has been previously urb-broadcast (by $p_{m.sender}$).


* Item                                                    :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673074743154
:END:
** Front
URB-integrity
** Back
a process urb-delivers a message /m/ at most once


* Item                                                    :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673123075114
:END:
** Front
URB-termination-1
** Back
if a non-faulty process urb-broadcasts a message /m/, it urb-delivers the message /m/

* Item                                                    :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673123145763
:END:
** Front
URB-termination-2
** Back
if a process urb-delivers a message /m/, then each non-faulty process urb-delivers the message /m/


* Item                                                    :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673123734463
:END:
** Front
urb delivery guarantees
** Back
- the non-faulty processes deliver the sam set of messages
- the set include all the messages broadcast by the non-fault processes
- each faulty process delivers a subset of messages delivered by the non-faulty processes
- two distinct faulty processes may deliver different subsets of messages

* Item                                                    :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673124976338
:END:
** Front
reliable broadcast is a weakened form of URB. 
** Back
weaker termination property:
If a non-faulty process

1. urb-broadcast a message /m/, or
2. urb-delivers a message /m/,

then each non-faulty process urb-delivers the message /m/.

* Item                                                    :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673125209888
:END:
** Front
key difference between reliable broadcast and uniformly reliable broadcast
** Back
a faulty process can deliver messages not delivered by the non-faulty processes.


* Item                                                    :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673125639538
:END:
** Front
algorithm implements $URB\_broadcast(m)$ and $URB\_deliver()$
** Back
[[file:./data/urb-broadcast-in-camp-emptyset.png]]

* Item                                                                  :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673126297964
:END:
** Front
Proof of $URB\_broadcast$ communication abstraction in $CAMP_{n,t}[\emptyset]$
** Back
- proof of the validity property
  algorithm forwards only messages that have been received
- proof of the integrity property
  A message is delivered only when it's received for the first time
- proof of termination-1 property
  - $p_i$ is non-faulty, it forwards message to every process.
  - channel is reliable, each process will eventually receive a copy of $MSG(m)$ and urb-deliver $m$.
- proof of termination-2 property
  - befor urb-delivering /m/, $p_j$ forwards $MSG(m)$ to all.
  - same reason above.

* Item                                                                  :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673126539817
:END:
** Front
Three types of message delivery guarantees
** Back
- First In, First Out
- Causal Order
- Total Order


* Item                                                                  :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673126718838
:END:
** Front
One-shot vs multi-shot algorithm
** Back
- One shot algorithms consider each message independently from the other message.
- multi-shot algorithms involve all the messages

* Item                                                                  :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673126777839
:END:
** Front
Is URB-broadcast a one-shot algorithm?
** Back
Yes.

* Item                                                                  :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673127207414
:END:
** Front
Are FIFO-URB and CO-URB one-shot algorithms?
** Back
NO.

* Item                                                                  :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673417303148
:END:
** Front
FIFO-URB message delivery property
** Back
If a process fifo-broadcasts $m$ and later fifo-broadcasts $m'$, no process fifo-delivers $m'$ unless it has fifo-delivered $m$.

* Item                                                                  :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673417757319
:END:
** Front
FIFO-broadcast architecture view
** Back
[[file:./data/fifo-urb-architecture-view.png]]

* Item                                                                  :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673417971843
:END:
** Front
FIFO-URB algorithm
** Back
[[file:./data/fifo-urb-algorithm.png]]

* Item                                                                  :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673418754593
:END:
** Front
Let $M$ be the set of messages, $\hat{M}=(M, \rightarrow_{M})$ be the partial order relation. $m \rightarrow_{M} m'$ if:
** Back
- $m$ and $m'$ are co-broadcast by the same process and $m$ is before $m'$, or
- $m$ has been co-delivered by a process $p_i$ before $p_i$ co-broadcasts $m'$, or
- there is message $m'' \in M$ such that $m \rightarrow_{M} m''$ and $m'' \rightarrow_{M} m'$.

* Item                                                                  :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673419204796
:END:
** Front
local order
** Back
If a process delivers a message $m$ before broadcasting a message $m'$, no process delivers $m'$ unless it has delivered $m$.


* Item                                                                  :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673420554847
:END:
** Front
proof sketch of CO is FIFO + local order
** Back
- CO -> FIFO + local order
  follows from its definition
- FIFO + local order -> CO
  - condition
    - two messages: $m$ and $m'$, FIFO and local order satisfied
    - $m \rightarrow_{M} m'$
    - process p delivers $m'$
  - target:
    - $p$ delivers $m$ before $m'$
  - sketch
    - as $m \rightarrow_{M} m'$, there is a finite sequence of messages $m_1 = m$ to $m_k = m'$, that have been broadcast by $q_1,\dots,q_k$.
    - for all x, we have $m_x \rightarrow_{M} m_{x+1}$.
    - for any x: one of the following cases holds:
      - if $q_x = q_{x+1}$ -> FIFO order
      - if $q_x \neq q_{x+1}$ -> local order
    - when p delivers $m_k$, it has delivered $m_{k-1}$.


* Item                                                                  :URB:
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:ANKI_NOTE_ID: 1673420973145
:END:
** Front
CO-broadcast algorithm on top of URB-broadcast
** Back
[[file:./data/urb-based-co-broadcast-in-camp-emptyset.png]]


